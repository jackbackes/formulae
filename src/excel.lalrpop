use std::str::FromStr;
use crate::parse::{Expr, Opcode, Error}; 

grammar;

Tier<Op,NextTier>: Box<Expr> = {
    Tier<Op,NextTier> Op NextTier => Box::new(Expr::Op(<>)),
    NextTier
};

pub Expr = Tier<ExprOp, Factor>;
Factor = Tier<FactorOp, SingleComparison>;
SingleComparison = Tier<SingleComparisonOp, MultiComparison>; 
MultiComparison = Tier<MultiComparisonOp, Term>; 

ExprOp: Opcode = { 
    "+" => Opcode::Add,
    "-" => Opcode::Subtract,
};

FactorOp: Opcode = {
    "*" => Opcode::Multiply,
    "/" => Opcode::Divide,
	"^" => Opcode::Exponent,
	"&" => Opcode::Concat,
	"%" => Opcode::Percent,
};

SingleComparisonOp: Opcode = {
	"=" => Opcode::Equal, 
	"<" => Opcode::LessThan,
	">" => Opcode::GreaterThan,
}; 

MultiComparisonOp: Opcode = {
	"<>" => Opcode::NotEqual,
	"<=" => Opcode::LessThanOrEqual,
	">=" => Opcode::GreaterThanOrEqual 
}; 

Err: Error = {
	"#NULL!" => Error::Null, 
	"#DIV/0!" => Error::Div, 
	"#VALUE!" => Error::Value, 
	"#REF!" => Error::Ref, 
	"#NAME?" => Error::Name,
	"#NUM!" => Error::Num, 
	"#N/A" => Error::NA, 
	"#GETTING_DATA" => Error::GettingData 
}

Comma<T>: Vec<T> = { 
    <mut v:(<T> r",|;")*> <e:T?> => match e { 
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    },
};

FunctionArgs = Comma<Expr>; 

Function: Box<Expr> = {
	<name:r"[a-zA-Z]+"> "(" <args:FunctionArgs> ")" => Box::new(Expr::Func { name: name.to_string(), args })
}

ArrayArgs = Comma<Expr>;

Array: Box<Expr> = {
	"{" <arr:ArrayArgs> "}" => Box::new(Expr::Array(arr))
}

Sheet : String = {
	<name:r"[^ ][^/\\?*\[\]]{1,31}!"> => name.replace("!", "")
}

A1: String = {
	<reference:r"(\$?[A-Z]{1,3}\$?[0-9]{1,6})(:\$?[A-Z]{1,3}\$?[0-9]{1,6})?|(\$?[A-Z]{1,3}:\$?[A-Z]{1,3})|(\$?[0-9]{1,6}:\$?[0-9]{1,3})"> => reference.to_string()
}

// Sheet name is optional
Cell: Box<Expr> = {
	<name:Sheet?> <reference: A1> => match name {
		None => Box::new(Expr::Cell { sheet: None, reference: reference.to_string() }), 
		Some(s) => Box::new(Expr::Cell { sheet: Some(s.to_string()), reference: reference.to_string() })
	} 
}

Text: String = {
	<text:r#""(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'"#> => {
		let mut chars = text.chars();
		chars.next();
		chars.next_back();
		chars.as_str().to_string()
	}
}; 

Bool: bool = {
	"TRUE" => true, 
	"FALSE" => false
}

Num: f32 = {
    r"([0-9]*[.])?[0-9]+" => f32::from_str(<>).unwrap()
};

Term: Box<Expr> = {
    Num => Box::new(Expr::Num(<>)),
	Err => Box::new(Expr::Error(<>)), 
	Bool => Box::new(Expr::Bool(<>)), 
	Text => Box::new(Expr::Text(<>)), 
	Cell => <>, 
	Function => <>, 
	Array => <>, 
    "(" <Expr> ")"
};
